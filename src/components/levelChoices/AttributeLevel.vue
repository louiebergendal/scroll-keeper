<template>
	<div class='card medium padding-tiny'>

		<h3 class="align-center margin-top-nano margin-bottom-tiny">Ã–ka en grundegenskap!</h3>

		<div>Vald bonus: {{tempLevelChoiceKey}}</div>

		<div
			v-for='attribute in attributes'
			:key='attribute.key'
			class='width-whole flex margin-nano width-whole'
		>
			<div
				:class="{ 'font-contrast-lowest': !canChooseAttribute(tempCharacterAttributes[attribute.key], selectedLevel) }"
				class="width-half flex"
			>
				<div
					:class="{
						'invalid': attributeChoiceIsNotValidButIsSelected(
							tempValidationSheet.metadata.invalidLevels,
							attribute.key,
							tempLevelChoiceKey
						)
					}"
					class="card dark width-whole"
				>
					<input
						type="radio" 
						id="{{attribute.key}}" 
						:value='attribute.key' 
						v-model="tempLevelChoiceKey" 
						name="attribute" 
						:disabled="!canChooseAttribute(tempCharacterAttributes[attribute.key], selectedLevel)"
						class="margin-tiny"
					/>

					<label for="{{attribute.key}}"> {{getAttributeShortName(attribute.key)}} </label>
				</div>

				<div
					v-if="tempLevelChoiceKey === attribute.key"
					:class="{
						'invalid': attributeChoiceIsNotValidButIsSelected(
							tempValidationSheet.metadata.invalidLevels,
							attribute.key,
							tempLevelChoiceKey
						)
					}"
					class="card dark width-fourth margin-left-tiny align-center"
				>
					{{tempCharacterAttributes[attribute.key]}} + 1
				</div>

				<div v-if="tempLevelChoiceKey !== attribute.key" class="card dark width-fourth margin-left-tiny align-center">
					{{tempCharacterAttributes[attribute.key]}}
				</div>

			</div>
		</div>

		<button :disabled="!isChangeable" type="submit" class="margin-top-tiny margin-left-nano" @click="submitNewAttributeLevel()">Submitta!</button>

	</div>
</template>

<script>
	import { useCharacterStore } from '../../stores/character'
	import { ref } from 'vue'
	import { attributes, getAttributeShortName, getAttributeLongName, canChooseAttribute } from '../../rules/characteristics/attributes'
	import { flattenCharacter } from '../../utilities/characterFlattener'
	import { levelChoiceIsValid } from '../../rules/utils'

	export default {
		props: ['selectedLevel'],
		setup(props) {
			const character = useCharacterStore()
			const selectedLevel = props.selectedLevel
			const isChangeable = ref(selectedLevel <= character.metadata.level)

			const tempCharacterSheet = flattenCharacter(character, selectedLevel - 1) // -1 to account for current lvling
			const tempValidationSheet = flattenCharacter(character, selectedLevel) 
			const tempCharacterAttributes = tempCharacterSheet.attributes
			let originalLevelChoiceKey = ''
			if (selectedLevel <= character.metadata.level) 
				originalLevelChoiceKey = character.history[selectedLevel].choice
			const tempLevelChoiceKey = ref(originalLevelChoiceKey)

			return {
				attributes,
				character,
				selectedLevel,
				tempCharacterAttributes,
				tempValidationSheet,
				tempLevelChoiceKey,
				getAttributeShortName,
				getAttributeLongName,
				canChooseAttribute,
				isChangeable
			}
		},
		methods: {
			attributeChoiceIsNotValidButIsSelected(invalidLevels, attributeKey, tempLevelChoiceKey) {
				if (!levelChoiceIsValid(attributeKey, invalidLevels)) {
					for (const invalidLevel in invalidLevels) {
						if (invalidLevels[invalidLevel] === tempLevelChoiceKey) return true
					}
				}
			},
			submitNewAttributeLevel() {
				this.character.submitNewLevelChoice(this.tempLevelChoiceKey, this.selectedLevel, 'attribute')
				this.$emit('update-tabs')
			},

		}
	}
</script>


<style>
	.invalid {
		background: rgb(247, 63, 46) !important;
	}
</style>
